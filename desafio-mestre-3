#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

#define TAM_FILA 5
#define TAM_PILHA 3
#define MAX_UNDO 20

// Representa√ß√£o de uma pe√ßa
typedef struct {
    char tipo; // 'I', 'O', 'T', 'L'
    int id;    // identificador √∫nico
} Peca;

// Estado completo do jogo (para snapshot / undo)
typedef struct {
    Peca fila[TAM_FILA];
    int frente;
    int qtd;       // quantidade atualmente na fila (0..TAM_FILA)
    Peca pilha[TAM_PILHA];
    int topo;      // -1 quando vazia
} GameState;

// Pilha de snapshots para desfazer
typedef struct {
    GameState snaps[MAX_UNDO];
    int topo; // √≠ndice do √∫ltimo snapshot v√°lido (-1 quando vazio)
} UndoStack;

// Gera pe√ßa com tipo aleat√≥rio e id sequencial
Peca gerarPeca() {
    static int next_id = 1;
    Peca p;
    const char tipos[] = {'I', 'O', 'T', 'L'};
    p.tipo = tipos[rand() % 4];
    p.id = next_id++;
    return p;
}

// Fun√ß√µes utilit√°rias de fila e pilha
int fila_final_index(const GameState *s) {
    return (s->frente + s->qtd) % TAM_FILA;
}

// Exibir estado atual (fila e pilha)
void mostrarEstado(const GameState *s) {
    printf("\n=== ESTADO ATUAL ===\n");
    // Fila
    printf("Fila (frente idx %d, qtd %d):\n", s->frente, s->qtd);
    if (s->qtd == 0) {
        printf("  (vazia)\n");
    } else {
        for (int i = 0; i < s->qtd; i++) {
            int pos = (s->frente + i) % TAM_FILA;
            printf("  [%d] %c (ID %d)\n", i, s->fila[pos].tipo, s->fila[pos].id);
        }
    }
    // Pilha
    printf("Pilha (topo idx %d):\n", s->topo);
    if (s->topo == -1) {
        printf("  (vazia)\n");
    } else {
        for (int i = s->topo; i >= 0; i--) {
            printf("  [%d] %c (ID %d)\n", i, s->pilha[i].tipo, s->pilha[i].id);
        }
    }
    printf("====================\n");
}

// Inicializa estado com fila cheia (5 pe√ßas) e pilha vazia
void inicializar(GameState *s) {
    s->frente = 0;
    s->qtd = TAM_FILA;
    s->topo = -1;
    for (int i = 0; i < TAM_FILA; i++) s->fila[i] = gerarPeca();
    // pilha inicialmente vazia
}

// Undo stack functions
void undo_init(UndoStack *u) { u->topo = -1; }

int undo_push(UndoStack *u, const GameState *s) {
    if (u->topo >= MAX_UNDO - 1) return 0; // cheio
    u->topo++;
    u->snaps[u->topo] = *s;
    return 1;
}

int undo_pop(UndoStack *u, GameState *s_out) {
    if (u->topo == -1) return 0;
    *s_out = u->snaps[u->topo];
    u->topo--;
    return 1;
}

void salvar_estado(UndoStack *u, const GameState *s) {
    if (!undo_push(u, s)) {
        // Se hist√≥rico cheio, descartamos o snapshot mais antigo (shift left)
        // para liberar espa√ßo: movemos tudo uma posi√ß√£o para a esquerda e colocamos no topo
        for (int i = 0; i < MAX_UNDO - 1; i++) u->snaps[i] = u->snaps[i+1];
        u->snaps[MAX_UNDO - 1] = *s;
        u->topo = MAX_UNDO - 1;
    }
}

// Opera√ß√µes principais (cada uma salva snapshot antes de modificar)
void enqueue_auto(GameState *s) {
    // Insere nova pe√ßa no final da fila, se houver espa√ßo.
    if (s->qtd >= TAM_FILA) return; // j√° cheia
    int idx = fila_final_index(s);
    s->fila[idx] = gerarPeca();
    s->qtd++;
}

void jogarPeca(GameState *s) {
    if (s->qtd == 0) {
        printf("N√£o h√° pe√ßa na fila para jogar.\n");
        return;
    }
    Peca p = s->fila[s->frente];
    printf("üïπÔ∏è Jogou pe√ßa: %c (ID %d)\n", p.tipo, p.id);
    s->frente = (s->frente + 1) % TAM_FILA;
    s->qtd--;
    // manter fila sempre cheia: enqueue autom√°tico (se poss√≠vel)
    enqueue_auto(s);
}

void reservarPeca(GameState *s) {
    if (s->qtd == 0) {
        printf("N√£o h√° pe√ßa na fila para reservar.\n");
        return;
    }
    if (s->topo >= TAM_PILHA - 1) {
        printf("Pilha cheia! N√£o √© poss√≠vel reservar.\n");
        return;
    }
    Peca p = s->fila[s->frente];
    // push na pilha
    s->topo++;
    s->pilha[s->topo] = p;
    printf("üì¶ Reservou pe√ßa: %c (ID %d) na pilha (topo %d)\n", p.tipo, p.id, s->topo);
    // remover da fila (dequeue)
    s->frente = (s->frente + 1) % TAM_FILA;
    s->qtd--;
    // manter fila cheia
    enqueue_auto(s);
}

void usarReservada(GameState *s) {
    if (s->topo == -1) {
        printf("Pilha vazia! Nada para usar.\n");
        return;
    }
    Peca p = s->pilha[s->topo];
    s->topo--;
    printf("üéØ Usou pe√ßa reservada: %c (ID %d)\n", p.tipo, p.id);
    // Ao usar reservado, mantemos fila cheia (nenhuma altera√ß√£o na fila em si),
    // mas pol√≠tica: ap√≥s usar, geramos uma nova pe√ßa no final para manter din√¢mica.
    enqueue_auto(s);
}

void trocarTopoComFrente(GameState *s) {
    if (s->qtd == 0) {
        printf("Fila vazia! Nada para trocar.\n");
        return;
    }
    if (s->topo == -1) {
        printf("Pilha vazia! Nada para trocar.\n");
        return;
    }
    Peca temp = s->pilha[s->topo];
    s->pilha[s->topo] = s->fila[s->frente];
    s->fila[s->frente] = temp;
    printf("üîÅ Troca realizada entre topo da pilha e frente da fila.\n");
}

void inverterFilaComPilha(GameState *s) {
    // Objetivo: trocar "conte√∫do l√≥gico" entre fila e pilha.
    // Regras adotadas:
    //  - Os primeiros (frente -> frente+2) elementos da fila (at√© 3) viram a pilha
    //    mantendo ordem: elemento mais pr√≥ximo da frente ser√° o fundo da pilha, topo ser√° o elemento mais pr√≥ximo.
    //  - A pilha, do topo para o fundo, virar√° os primeiros elementos da fila (mantendo ordem de leitura).
    //  - Se tamanhos diferentes, completamos a fila gerando novas pe√ßas para ficar com TAM_FILA elementos.
    // Exemplo: fila = [A,B,C,D,E], pilha(top)-> [X,Y] => ap√≥s inverter:
    //   nova pilha (top->) = [C,B,A] (at√© 3), e nova fila come√ßa com X,Y, ... (resto gerado)
    GameState tmp = *s; // c√≥pia segura

    // Extrair at√© 3 elementos l√≥gicos da fila (frente..)
    Peca fromFila[TAM_PILHA];
    int nFromFila = 0;
    for (int i = 0; i < tmp.qtd && nFromFila < TAM_PILHA; i++) {
        int pos = (tmp.frente + i) % TAM_FILA;
        fromFila[nFromFila++] = tmp.fila[pos];
    }

    // Extrair elementos da pilha (do fundo ao topo) para formar prefixo da nova fila
    int nPilha = tmp.topo + 1;
    Peca fromPilha[TAM_PILHA];
    for (int i = 0; i < nPilha; i++) {
        fromPilha[i] = tmp.pilha[i]; // 0 = fundo, topo = nPilha-1
    }

    // Construir nova pilha: pegar elementos fromFila e empilhar de modo que elemento
    // closer to front becomes fundo -> topo order: fromFila[nFromFila-1] ... fromFila[0]
    int novoTopo = -1;
    Peca novaPilha[TAM_PILHA];
    for (int i = nFromFila - 1; i >= 0; i--) {
        novoTopo++;
        novaPilha[novoTopo] = fromFila[i];
    }

    // Construir nova fila: prefixo vindo da pilha (do fundo ao topo) mantendo ordem de leitura:
    // primeiros elementos da fila ser√£o fromPilha[0], fromPilha[1], ..., fromPilha[nPilha-1]
    GameState novo;
    novo.frente = 0;
    novo.qtd = 0;
    novo.topo = novoTopo;

    // Preencher com elementos vindos da pilha
    for (int i = 0; i < nPilha && novo.qtd < TAM_FILA; i++) {
        int idx = fila_final_index(&novo);
        novo.fila[idx] = fromPilha[i];
        novo.qtd++;
    }
    // Se ainda faltam posi√ß√µes, preencher com elementos vindos da antiga fila (que n√£o foram movidos),
    // come√ßando ap√≥s os nFromFila elementos extra√≠dos
    int takenFromFila = nFromFila;
    for (int i = takenFromFila; novo.qtd < TAM_FILA && i < tmp.qtd; i++) {
        int pos = (tmp.frente + i) % TAM_FILA;
        int idx = fila_final_index(&novo);
        novo.fila[idx] = tmp.fila[pos];
        novo.qtd++;
    }
    // Se ainda faltar, gerar novas pe√ßas
    while (novo.qtd < TAM_FILA) {
        int idx = fila_final_index(&novo);
        novo.fila[idx] = gerarPeca();
        novo.qtd++;
    }

    // Copiar nova pilha para estado
    for (int i = 0; i <= novoTopo; i++) novo.pilha[i] = novaPilha[i];

    // Substituir estado atual com novo
    *s = novo;
    printf("üîÄ Invers√£o entre fila e pilha executada.\n");
}

// Fun√ß√£o para salvar estado e executar a√ß√£o (pattern: salvar antes -> executar)
void executar_e_salvar(UndoStack *undo, GameState *s, void (*acao)(GameState *)) {
    // Salva snapshot atual
    salvar_estado(undo, s);
    // Executa a√ß√£o passada
    acao(s);
}

// Inicializa um GameState copiado (√∫til para enfileirar automaticamente com c√≥pia)
void garantirFilaCheia(GameState *s) {
    while (s->qtd < TAM_FILA) {
        int idx = fila_final_index(s);
        s->fila[idx] = gerarPeca();
        s->qtd++;
    }
}

// Programa principal com menu
int main() {
    srand((unsigned)time(NULL));

    GameState estado;
    inicializar(&estado);

    // garantir fila cheia (j√° est√°)
    garantirFilaCheia(&estado);

    UndoStack undo;
    undo_init(&undo);

    int opcao;
    do {
        mostrarEstado(&estado);
        printf("\n--- MENU N√çVEL MESTRE ---\n");
        printf("1 - Jogar pe√ßa (dequeue)\n");
        printf("2 - Reservar pe√ßa (push)\n");
        printf("3 - Usar pe√ßa reservada (pop)\n");
        printf("4 - Trocar topo da pilha com frente da fila\n");
        printf("5 - Desfazer √∫ltima jogada\n");
        printf("6 - Inverter fila com pilha\n");
        printf("0 - Sair\n");
        printf("Escolha: ");
        if (scanf("%d", &opcao) != 1) {
            // limpar input e continuar
            while (getchar() != '\n');
            printf("Entrada inv√°lida.\n");
            continue;
        }

        switch (opcao) {
            case 1:
                executar_e_salvar(&undo, &estado, jogarPeca);
                // Garantir fila cheia caso a a√ß√£o n√£o tenha enfileirado (safety)
                garantirFilaCheia(&estado);
                break;

            case 2:
                executar_e_salvar(&undo, &estado, reservarPeca);
                garantirFilaCheia(&estado);
                break;

            case 3:
                executar_e_salvar(&undo, &estado, usarReservada);
                garantirFilaCheia(&estado);
                break;

            case 4:
                executar_e_salvar(&undo, &estado, trocarTopoComFrente);
                break;

            case 5: {
                GameState prev;
                if (!undo_pop(&undo, &prev)) {
                    printf("Nada para desfazer.\n");
                } else {
                    estado = prev;
                    printf("‚Ü©Ô∏è Desfeito para o estado anterior.\n");
                }
                break;
            }

            case 6:
                executar_e_salvar(&undo, &estado, inverterFilaComPilha);
                break;

            case 0:
                printf("Encerrando...\n");
                break;

            default:
                printf("Op√ß√£o inv√°lida.\n");
        }

    } while (opcao != 0);

    return 0;
}
